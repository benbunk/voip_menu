<?php

/*
 *
 * Our custom menu_tree strcut.
 *
 * $items [
     mlid [
       item-title
       item-path
       item-node
       items [
         item:n []
       ]
     ]
     item:n []
  ]
 */

/**
 * Implementation of hook_menu().
 */
function voip_menu_menu() {
  $items = array();

  $items['admin/voip/voip_menu'] = array(
    'title' => 'VoIP Menu',
    'description' => 'Control which navigation menu is used for the VoIP Menu script.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('voip_menu_default_form', NULL),
    'access arguments' => array('administer voip drupal framework'),
    'file' => 'voip_menu.admin.inc',
  );

  return $items;
}

/**
 * Implementation of hook_voipscript_get_script_names().
 *
 * @return array
 */
function voip_menu_voipscript_get_script_names() {
  return array('voip_menu_ivr',);
}

/**
 * Check that a particular menu name exists in a given list of menus.
 *
 * @param $menus - Array of menus from @see menu_get_names().
 * @param $menu_name - The string name of the menu to find.
 * @return NULL or Numeric - NULL if not present, Numeric array key if present.
 */
function _check_menu_exists($menus, $menu_name) {
  if(!is_string($menu_name)) {
    return NULL;
  }
  $flipped = array_flip($menus);
  return isset($flipped[$menu_name]) ? $flipped[$menu_name] : NULL;
}

/**
 * Implementation of hook_voipscript_load_script($script_name, $params = NULL).
 *
 * @param $script_name
 * @param null $params
 * @return VoipScript
 */
function voip_menu_voipscript_load_script($script_name, $params = NULL) {

  // Check if it's us.
  if ($script_name !== 'voip_menu_ivr') { return; }

  // Check that a menu is selected in the admin settings and the menu exists.
  $menu_name = variable_get('voip_menu_selected_menu', 'navigation');
  if(_check_menu_exists(menu_get_names(FALSE), $menu_name) === NULL) {
    watchdog('voip_menu', 'Invalid default Menu passed to voip_menu_voipscript_load_script. See admin/voip/voip_menu page.');
    return FALSE;
  }


  // Get the entire menu tree.
  $menu_tree = voip_menu_menu_tree_page_data($menu_name);

  // Recursively loop the menu and condense the data for walking.
  $built_menu = _recursive_menu_build($menu_tree['tree']);

  // Create the script.
  $script = new VoipScript('voip_menu_ivr');

  // Allow other modules to modify the script result.
  $val = module_invoke_all('voip_menu_before_build', $built_menu, $script);
  $script = $val[0];

  $script->addLabel('hang up');
  $script->addSay(t('Thank you for using the voice based version of our site. Goodbye.'));
  $script->addHangup();

  return $script;
}

/**
 *
 * Build a menu tree that condenses all the information we need to efficiently walk and create a script from.
 *
 * @param $menu_tree
 * @return array
 */
function _recursive_menu_build($menu_tree) {
   $result = array();
   foreach ($menu_tree as $item) {
     $item_id = $item['link']['mlid'];
     // Do the individual menu magic here.
     $result[$item_id]['mlid'] = $item['link']['mlid'];
     $result[$item_id]['link_title'] = $item['link']['link_title'];
     $result[$item_id]['link_path'] = $item['link']['link_path'];
     $temp = menu_get_item($item['link']['link_path']);
     $result[$item_id]['node'] = $temp['map'][1];


     if ($item['below'] != FALSE) {
       $result[$item_id]['items'] = _recursive_menu_build($item['below']);
     }
   }

  return $result;
}

/**
 *
 * Implementation of hook_voip_menu_before_build().
 *
 * @param $ivr_items
 * @param $script
 * @return mixed
 */
function voip_menu_voip_menu_before_build($ivr_items, $script) {
  // Welcome script.
  $script->addLabel('welcome');
  $script->addSay('Welcome to  ' . variable_get('site_name', 'Drupal Menu.'));

  $script = _recursive_ivr_build(
    $ivr_items, $script, 'main_menu', 'Main menu. Main menu. The following options are available, ');

  return $script;
}

/**
 *
 * Walk a condensed menu to recursively generate an IVR menu per node in the menu tree.
 *
 * @param $built_tree
 * @param $script
 * @param $menu_label
 * @param $menu_say
 * @return mixed
 */
function _recursive_ivr_build($built_tree, $script, $menu_label, $menu_say) {
  $script->addLabel($menu_label);
  $script->addSay($menu_say);

  $count = 1;
  $input_options = array();
  $menu_option_say = '';
  foreach($built_tree as $item) {
    $menu_option_say .= 'press ' . $count . '. For ' . $item['link_title'] . '. ';

    $input_options[$count] = $item['mlid'];

    $count++;
  }
  $input_options['#'] = 'hang up';
  $input_options['i'] = 'hang up';
  $input_options['t'] = 'hang up';

  $invalid_msg = t('Invalid option selected.');
  $script->addRunIvrMenu($menu_option_say, $input_options, $invalid_msg);
  $script->addGoto('%ivr_option_selected');

  for($i = 1; $i < count($input_options) - 2; $i++) {
    $script->addLabel($input_options[$i]); // Add the label built above.
    $script->addSay($built_tree[$input_options[$i]]['node']->teaser);

    // Build sub menus as required.
    if (is_array($built_tree[$input_options[$i]]['items'])) {
      foreach($built_tree[$input_options[$i]]['items'] as $item) {
        $script = _recursive_ivr_build(array($item['mlid'] => $item), $script, $item['mlid'], '');
      }
    }
    $script->addGoto('main_menu');
  }

  return $script;
}



















/****** Hide this extra far down so I don't have to see this ********/

/**
 *
 * Implemented our own copy of @see menu_tree_page_data. The code works well but they condense the menu tree by removing
 * the children which is what we need.
 *
 * @param string $menu_name
 * @return array
 */
function voip_menu_menu_tree_page_data($menu_name = 'navigation') {
  static $tree = array();

  // Load the menu item corresponding to the current page.
  if ($item = menu_get_item()) {
    // Generate a cache ID (cid) specific for this page.
    $cid = 'links:'. $menu_name .':page-cid:'. $item['href'] .':'. (int)$item['access'];

    if (!isset($tree[$cid])) {
      // If the static variable doesn't have the data, check {cache_menu}.
      //$cache = cache_get($cid, 'cache_menu');
      /*if ($cache && isset($cache->data)) {
        // If the cache entry exists, it will just be the cid for the actual data.
        // This avoids duplication of large amounts of data.
        $cache = cache_get($cache->data, 'cache_menu');
        if ($cache && isset($cache->data)) {
          $data = $cache->data;
        }
      }*/
      // If the tree data was not in the cache, $data will be NULL.
      if (!isset($data)) {
        // Build and run the query, and build the tree.
        if ($item['access']) {
          // Check whether a menu link exists that corresponds to the current path.
          $args = array($menu_name, $item['href']);
          $placeholders = "'%s'";
          if (drupal_is_front_page()) {
            $args[] = '<front>';
            $placeholders .= ", '%s'";
          }
          $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path IN (". $placeholders .")", $args));

          if (empty($parents)) {
            // If no link exists, we may be on a local task that's not in the links.
            // TODO: Handle the case like a local task on a specific node in the menu.
            $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path = '%s'", $menu_name, $item['tab_root']));
          }
          // We always want all the top-level links with plid == 0.
          $parents[] = '0';

          // Use array_values() so that the indices are numeric for array_merge().
          $args = $parents = array_unique(array_values($parents));
          $placeholders = implode(', ', array_fill(0, count($args), '%d'));
          $expanded = variable_get('menu_expanded', array());
          // Check whether the current menu has any links set to be expanded.
          if (in_array($menu_name, $expanded)) {
            // Collect all the links set to be expanded, and then add all of
            // their children to the list as well.
            do {
              $result = db_query("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND expanded = 1 AND has_children = 1 AND plid IN (". $placeholders .') AND mlid NOT IN ('. $placeholders .')', array_merge(array($menu_name), $args, $args));
              $num_rows = FALSE;
              while ($item = db_fetch_array($result)) {
                $args[] = $item['mlid'];
                $num_rows = TRUE;
              }
              $placeholders = implode(', ', array_fill(0, count($args), '%d'));
            } while ($num_rows);
          }
          array_unshift($args, $menu_name);
        }
        else {
          // Show only the top-level menu items when access is denied.
          $args = array($menu_name, '0');
          $placeholders = '%d';
          $parents = array();
        }
        // Select the links from the table, and recursively build the tree. We
        // LEFT JOIN since there is no match in {menu_router} for an external
        // link.
        $data['tree'] = menu_tree_data(db_query("
          SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*
          FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path
          WHERE ml.menu_name = '%s' AND ml.plid IN (". $placeholders .")
          ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);
        $data['node_links'] = array();
        //menu_tree_collect_node_links($data['tree'], $data['node_links']);
        // Cache the data, if it is not already in the cache.
        //$tree_cid = _menu_tree_cid($menu_name, $data);
        //if (!cache_get($tree_cid, 'cache_menu')) {
        //  cache_set($tree_cid, $data, 'cache_menu');
        //}
        // Cache the cid of the (shared) data using the page-specific cid.
        //cache_set($cid, $tree_cid, 'cache_menu');
      }
      // Check access for the current user to each item in the tree.
      //menu_tree_check_access($data['tree'], $data['node_links']);
      //$tree[$cid] = $data['tree'];
    }
    return $data;
  }

  return array();
}
